[{"title":"MySQL 性能优化技巧","date":"2017-10-07T02:11:43.000Z","path":"2017/10/07/MySQL-性能优化技巧/","text":"一、背景最近公司项目添加新功能，上线后发现有些功能的列表查询时间很久。原因是新功能用到旧功能的接口，而这些旧接口的 SQL 查询语句关联5,6张表且编写不够规范，导致 MySQL 在执行 SQL 语句时索引失效，进行全表扫描。原本负责优化的同事有事请假回家，因此优化查询数据的问题落在笔者手中。笔者在查阅网上 SQL 优化的资料后成功解决了问题，在此从全局角度记录和总结 MySQL 查询优化相关技巧。 二、优化思路数据查询慢，不代表 SQL 语句写法有问题。 首先，我们需要找到问题的源头才能“对症下药”。笔者用一张流程图展示 MySQL 优化的思路： 无需更多言语，从图中可以清楚地看出，导致数据查询慢的原因有多种，如：缓存失效，在此一段时间内由于高并发访问导致 MySQL 服务器崩溃；SQL 语句编写问题；MySQL 服务器参数问题；硬件配置限制 MySQL 服务性能问题等。 三、查看 MySQL 服务器运行的状态值如果系统的并发请求数不高，且查询速度慢，可以忽略该步骤直接进行 SQL 语句调优步骤。 执行命令： 1show status 由于返回结果太多，此处不贴出结果。其中，再返回的结果中，我们主要关注 “Queries”、“Threads_connected” 和 “Threads_running” 的值，即查询次数、线程连接数和线程运行数。 我们可以通过执行如下脚本监控 MySQL 服务器运行的状态值 123456#!/bin/bashwhile truedomysqladmin -uroot -p&quot;密码&quot; ext | awk &apos;/Queries/&#123;q=$4&#125;/Threads_connected/&#123;c=$4&#125;/Threads_running/&#123;r=$4&#125;END&#123;printf(&quot;%d %d %d\\n&quot;,q,c,r)&#125;&apos; &gt;&gt; status.txtsleep 1done 执行该脚本 24 小时，获取 status.txt 里的内容，再次通过 awk 计算每秒请求 MySQL 服务的次数 1awk &apos;&#123;q=$1-last;last=$1&#125;&#123;printf(&quot;%d %d %d\\n&quot;,q,$2,$3)&#125;&apos; status.txt 复制计算好的内容到 Excel 中生成图表观察数据周期性。 如果观察的数据有周期性的变化，如上图的解释，需要修改缓存失效策略。 例如： 通过随机数在[3,6,9] 区间获取其中一个值作为缓存失效时间，这样分散了缓存失效时间，从而节省了一部分内存的消耗。 当访问高峰期时，一部分请求分流到未失效的缓存，另一部分则访问 MySQL 数据库，这样减少了 MySQL 服务器的压力。 四、获取需要优化的 SQL 语句4.1 方式一：查看运行的线程执行命令：1show processlist 返回结果：1234567mysql&gt; show processlist;+----+------+-----------+------+---------+------+----------+------------------+| Id | User | Host | db | Command | Time | State | Info |+----+------+-----------+------+---------+------+----------+------------------+| 9 | root | localhost | test | Query | 0 | starting | show processlist |+----+------+-----------+------+---------+------+----------+------------------+1 row in set (0.00 sec) 从返回结果中我们可以了解该线程执行了什么命令/SQL 语句以及执行的时间。实际应用中，查询的返回结果会有 N 条记录。 其中，返回的 State 的值是我们判断性能好坏的关键，其值出现如下内容，则该行记录的 SQL 语句需要优化：123456Converting HEAP to MyISAM # 查询结果太大时，把结果放到磁盘，严重Create tmp table #创建临时表，严重Copying to tmp table on disk #把内存临时表复制到磁盘，严重locked #被其他查询锁住，严重loggin slow query #记录慢查询Sorting result #排序 State 字段有很多值，如需了解更多，可以参看文章末尾提供的链接。 4.2 方式二：开启慢查询日志在配置文件 my.cnf 中的 [mysqld] 一行下边添加两个参数： 12345slow_query_log = 1slow_query_log_file=/var/lib/mysql/slow-query.loglong_query_time = 2log_queries_not_using_indexes = 1 其中，slow_query_log = 1 表示开启慢查询； slow_query_log_file 表示慢查询日志存放的位置； long_query_time = 2 表示查询 &gt;=2 秒才记录日志； log_queries_not_using_indexes = 1 记录没有使用索引的 SQL 语句。 注意：slow_query_log_file 的路径不能随便写，否则 MySQL 服务器可能没有权限将日志文件写到指定的目录中。建议直接复制上文的路径。 修改保存文件后，重启 MySQL 服务。在 /var/lib/mysql/ 目录下会创建 slow-query.log 日志文件。连接 MySQL 服务端执行如下命令可以查看配置情况。 123show variables like &apos;slow_query%&apos;;show variables like &apos;long_query_time&apos;; 测试慢查询日志： 1234567mysql&gt; select sleep(2);+----------+| sleep(2) |+----------+| 0 |+----------+1 row in set (2.00 sec) 打开慢查询日志文件 12345678910[root@localhost mysql]# vim /var/lib/mysql/slow-query.log/usr/sbin/mysqld, Version: 5.7.19-log (MySQL Community Server (GPL)). started with:Tcp port: 0 Unix socket: /var/lib/mysql/mysql.sockTime Id Command Argument# Time: 2017-10-05T04:39:11.408964Z# User@Host: root[root] @ localhost [] Id: 3# Query_time: 2.001395 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0use test;SET timestamp=1507178351;select sleep(2); 我们可以看到刚才执行了 2 秒的 SQL 语句被记录下来了。 虽然在慢查询日志中记录查询慢的 SQL 信息，但是日志记录的内容密集且不易查阅。因此，我们需要通过工具将 SQL 筛选出来。 MySQL 提供 mysqldumpslow 工具对日志进行分析。我们可以使用 mysqldumpslow –help 查看命令相关用法。 常用参数如下： 12345678910-s：排序方式，后边接着如下参数 c：访问次数 l：锁定时间 r：返回记录 t：查询时间al：平均锁定时间ar：平均返回记录书at：平均查询时间-t：返回前面多少条的数据-g：翻遍搭配一个正则表达式，大小写不敏感 案例： 12345678获取返回记录集最多的10个sqlmysqldumpslow -s r -t 10 /var/lib/mysql/slow-query.log获取访问次数最多的10个sqlmysqldumpslow -s c -t 10 /var/lib/mysql/slow-query.log获取按照时间排序的前10条里面含有左连接的查询语句mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/slow-query.log 五、分析 SQL 语句5.1 方式一：explain筛选出有问题的 SQL，我们可以使用 MySQL 提供的 explain 查看 SQL 执行计划情况（关联表，表查询顺序、索引使用情况等）。 用法： 1explain select * from category; 返回结果： 1234567mysql&gt; explain select * from category;+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+| id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra |+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+| 1 | SIMPLE | category | NULL | ALL | NULL | NULL | NULL | NULL | 1 | 100.00 | NULL |+----+-------------+----------+------------+------+---------------+------+---------+------+------+----------+-------+1 row in set, 1 warning (0.00 sec) 字段解释：1) id：select 查询序列号。id相同，执行顺序由上至下；id不同，id值越大优先级越高，越先被执行 2) select_type：查询数据的操作类型，其值如下： 123456simple：简单查询，不包含子查询或 unionprimary:包含复杂的子查询，最外层查询标记为该值subquery：在 select 或 where 包含子查询，被标记为该值derived：在 from 列表中包含的子查询被标记为该值，MySQL 会递归执行这些子查询，把结果放在临时表union：若第二个 select 出现在 union 之后，则被标记为该值。若 union 包含在 from 的子查询中，外层 select 被标记为 derived union result：从 union 表获取结果的 select 3) table：显示该行数据是关于哪张表 4) partitions：匹配的分区 5) type：表的连接类型，其值，性能由高到底排列如下： 1234567system：表只有一行记录，相当于系统表const：通过索引一次就找到，只匹配一行数据eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常用于主键或唯一索引扫描ref：非唯一性索引扫描，返回匹配某个单独值的所有行。用于=、&lt; 或 &gt; 操作符带索引的列range：只检索给定范围的行，使用一个索引来选择行。一般使用between、&gt;、&lt;情况index：只遍历索引树ALL：全表扫描，性能最差 注：前5种情况都是理想情况的索引使用情况。通常优化至少到range级别，最好能优化到 ref 6) possible_keys：指出 MySQL 使用哪个索引在该表找到行记录。如果该值为 NULL，说明没有使用索引，可以建立索引提高性能 7) key：显示 MySQL 实际使用的索引。如果为 NULL，则没有使用索引查询 8) key_len：表示索引中使用的字节数，通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好显示的是索引字段的最大长度，并非实际使用长度 9) ref：显示该表的索引字段关联了哪张表的哪个字段 10) rows：根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好 11) filtered：返回结果的行数占读取行数的百分比，值越大越好 12) extra： 包含不合适在其他列中显示但十分重要的额外信息，常见的值如下： 123456using filesort：说明 MySQL 会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。出现该值，应该优化 SQLusing temporary：使用了临时表保存中间结果，MySQL 在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。出现该值，应该优化 SQL using index：表示相应的 select 操作使用了覆盖索引，避免了访问表的数据行，效率不错using where：where 子句用于限制哪一行using join buffer：使用连接缓存distinct：发现第一个匹配后，停止为当前的行组合搜索更多的行 注意：出现前 2 个值，SQL 语句必须要优化。 5.2 方式二：profiling使用 profiling 命令可以了解 SQL 语句消耗资源的详细信息（每个执行步骤的开销）。 5.2.1 查看 profile 开启情况1select @@profiling; 返回结果：1234567mysql&gt; select @@profiling;+-------------+| @@profiling |+-------------+| 0 |+-------------+1 row in set, 1 warning (0.00 sec) 0 表示关闭状态,1 表示开启 5.2.2 启用 profile1set profiling = 1; 返回结果： 12345678910mysql&gt; set profiling = 1; Query OK, 0 rows affected, 1 warning (0.00 sec)mysql&gt; select @@profiling;+-------------+| @@profiling |+-------------+| 1 |+-------------+1 row in set, 1 warning (0.00 sec) 在连接关闭后，profiling 状态自动设置为关闭状态。 5.2.3 查看执行的 SQL 列表1show profiles; 返回结果： 123456789101112131415mysql&gt; show profiles;+----------+------------+------------------------------+| Query_ID | Duration | Query |+----------+------------+------------------------------+| 1 | 0.00062925 | select @@profiling || 2 | 0.00094150 | show tables || 3 | 0.00119125 | show databases || 4 | 0.00029750 | SELECT DATABASE() || 5 | 0.00025975 | show databases || 6 | 0.00023050 | show tables || 7 | 0.00042000 | show tables || 8 | 0.00260675 | desc role || 9 | 0.00074900 | select name,is_key from role |+----------+------------+------------------------------+9 rows in set, 1 warning (0.00 sec) 该命令执行之前，需要执行其他 SQL 语句才有记录。 5.2.4 查询指定 ID 的执行详细信息1show profile for query Query_ID; 返回结果： 123456789101112131415161718192021mysql&gt; show profile for query 9;+----------------------+----------+| Status | Duration |+----------------------+----------+| starting | 0.000207 || checking permissions | 0.000010 || Opening tables | 0.000042 || init | 0.000050 || System lock | 0.000012 || optimizing | 0.000003 || statistics | 0.000011 || preparing | 0.000011 || executing | 0.000002 || Sending data | 0.000362 || end | 0.000006 || query end | 0.000006 || closing tables | 0.000006 || freeing items | 0.000011 || cleaning up | 0.000013 |+----------------------+----------+15 rows in set, 1 warning (0.00 sec) 每行都是状态变化的过程以及它们持续的时间。Status 这一列和 show processlist 的 State 是一致的。因此，需要优化的注意点与上文描述的一样。 其中，Status 字段的值同样可以参考末尾链接。 5.2.5 获取 CPU、 Block IO 等信息12345show profile block io,cpu for query Query_ID;show profile cpu,block io,memory,swaps,context switches,source for query Query_ID;show profile all for query Query_ID; 六、优化手段主要以查询优化、索引使用和表结构设计方面进行讲解。 6.1 查询优化1) 避免 SELECT *，需要什么数据，就查询对应的字段。 2) 小表驱动大表，即小的数据集驱动大的数据集。如：以 A，B 两表为例，两表通过 id 字段进行关联。 12345当 B 表的数据集小于 A 表时，用 in 优化 exist；使用 in ，两表执行顺序是先查 B 表，再查 A 表select * from A where id in (select id from B)当 A 表的数据集小于 B 表时，用 exist 优化 in；使用 exists，两表执行顺序是先查 A 表，再查 B 表select * from A where exists (select 1 from B where B.id = A.id) 3) 一些情况下，可以使用连接代替子查询，因为使用 join，MySQL 不会在内存中创建临时表。 4) 适当添加冗余字段，减少表关联。 5) 合理使用索引（下文介绍）。如：为排序、分组字段建立索引，避免 filesort 的出现。 6.2 索引使用6.2.1 适合使用索引的场景1) 主键自动创建唯一索引 2) 频繁作为查询条件的字段 3) 查询中与其他表关联的字段 4) 查询中排序的字段 5) 查询中统计或分组字段 6.2.2 不适合使用索引的场景1) 频繁更新的字段 2) where 条件中用不到的字段 3) 表记录太少 4) 经常增删改的表 5) 字段的值的差异性不大或重复性高 6.2.3 索引创建和使用原则1) 单表查询：哪个列作查询条件，就在该列创建索引 2) 多表查询：left join 时，索引添加到右表关联字段；right join 时，索引添加到左表关联字段 3) 不要对索引列进行任何操作（计算、函数、类型转换） 4) 索引列中不要使用 !=，&lt;&gt; 非等于 5) 索引列不要为空，且不要使用 is null 或 is not null 判断 6) 索引字段是字符串类型，查询条件的值要加’’单引号,避免底层类型自动转换 违背上述原则可能会导致索引失效，具体情况需要使用 explain 命令进行查看 6.2.4 索引失效情况除了违背索引创建和使用原则外，如下情况也会导致索引失效： 1) 模糊查询时，以 % 开头 2) 使用 or 时，如：字段1（非索引）or 字段2（索引）会导致索引失效。 3) 使用复合索引时，不使用第一个索引列。 index(a,b,c) ，以字段 a,b,c 作为复合索引为例： 语句 索引是否生效 where a = 1 是，字段 a 索引生效 where a = 1 and b = 2 是，字段 a 和 b 索引生效 where a = 1 and b = 2 and c = 3 是，全部生效 where b = 2 或 where c = 3 否 where a = 1 and c = 3 字段 a 生效，字段 c 失效 where a = 1 and b &gt; 2 and c = 3 字段 a，b 生效，字段 c 失效 where a = 1 and b like ‘xxx%’ and c = 3 字段 a，b 生效，字段 c 失效 6.3 数据库表结构设计6.3.1 选择合适的数据类型1) 使用可以存下数据最小的数据类型 2) 使用简单的数据类型。int 要比 varchar 类型在mysql处理简单 3) 尽量使用 tinyint、smallint、mediumint 作为整数类型而非 int 4) 尽可能使用 not null 定义字段，因为 null 占用4字节空间 5) 尽量少用 text 类型,非用不可时最好考虑分表 6) 尽量使用 timestamp 而非 datetime 7) 单表不要有太多字段，建议在 20 以内 6.3.2 表的拆分当数据库中的数据非常大时，查询优化方案也不能解决查询速度慢的问题时，我们可以考虑拆分表，让每张表的数据量变小，从而提高查询效率。 1) 垂直拆分：将表中多个列分开放到不同的表中。例如用户表中一些字段经常被访问，将这些字段放在一张表中，另外一些不常用的字段放在另一张表中。插入数据时，使用事务确保两张表的数据一致性。 2) 水平拆分：按照行进行拆分。例如用户表中，使用用户ID，对用户ID取10的余数，将用户数据均匀的分配到0~9的10个用户表中。查找时也按照这个规则查询数据。 6.3.3 读写分离一般情况下对数据库而言都是“读多写少”。换言之，数据库的压力多数是因为大量的读取数据的操作造成的。我们可以采用数据库集群的方案，使用一个库作为主库，负责写入数据；其他库为从库，负责读取数据。这样可以缓解对数据库的访问压力。 七、服务器参数调优7.1 内存相关sort_buffer_size 排序缓冲区内存大小 join_buffer_size 使用连接缓冲区大小 read_buffer_size 全表扫描时分配的缓冲区大小 7.2 IO 相关Innodb_log_file_size 事务日志大小 Innodb_log_files_in_group 事务日志个数 Innodb_log_buffer_size 事务日志缓冲区大小 Innodb_flush_log_at_trx_commit 事务日志刷新策略，其值如下： 0：每秒进行一次 log 写入 cache，并 flush log 到磁盘 1：在每次事务提交执行 log 写入 cache，并 flush log 到磁盘 2：每次事务提交，执行 log 数据写到 cache，每秒执行一次 flush log 到磁盘 7.3 安全相关expire_logs_days 指定自动清理 binlog 的天数 max_allowed_packet 控制 MySQL 可以接收的包的大小 skip_name_resolve 禁用 DNS 查找 read_only 禁止非 super 权限用户写权限 skip_slave_start 级你用 slave 自动恢复 7.4 其他max_connections 控制允许的最大连接数 tmp_table_size 临时表大小 max_heap_table_size 最大内存表大小 笔者并没有使用这些参数对 MySQL 服务器进行调优，具体详情介绍和性能效果请参考文章末尾的资料或另行百度。 八、硬件选购和参数优化硬件的性能直接决定 MySQL 数据库的性能。硬件的性能瓶颈，直接决定 MySQL 数据库的运行数据和效率。 作为软件开发程序员，我们主要关注软件方面的优化内容，以下硬件方面的优化作为了解即可 8.1 内存相关内存的 IO 比硬盘的速度快很多，可以增加系统的缓冲区容量，使数据在内存停留的时间更长，以减少磁盘的 IO 8.2 磁盘 I/O 相关1) 使用 SSD 或 PCle SSD 设备，至少获得数百倍甚至万倍的 IOPS 提升 2) 购置阵列卡同时配备 CACHE 及 BBU 模块，可以明显提升 IOPS 3) 尽可能选用 RAID-10，而非 RAID-5 8.3 配置 CUP 相关在服务器的 BIOS 设置中，调整如下配置： 1) 选择 Performance Per Watt Optimized（DAPC）模式，发挥 CPU 最大性能 2) 关闭 C1E 和 C States 等选项，提升 CPU 效率 3) Memory Frequency（内存频率）选择 Maximum Performance 九、参考资料 https://dev.mysql.com/doc/refman/5.7/en/show-status.html show status 语法 https://dev.mysql.com/doc/refman/5.7/en/show-processlist.html show processlist 语法 https://dev.mysql.com/doc/refman/5.7/en/general-thread-states.html 线程状态 https://dev.mysql.com/doc/refman/5.7/en/explain-output.html explain 语法 https://dev.mysql.com/doc/refman/5.7/en/show-profile.html show profile 语法 http://blog.csdn.net/nightelve/article/details/17393631 MySQL 服务器参数调优 http://blog.csdn.net/qq_22929803/article/details/51237056 MySQL 服务器参数调优 http://blog.chinaunix.net/uid-11640640-id-3426908.html https://segmentfault.com/a/1190000006158186 http://blog.csdn.net/gzh0222/article/details/7976127","tags":[{"name":"MySQL 调优","slug":"MySQL-调优","permalink":"http://www.extlight.com/tags/MySQL-调优/"}]},{"title":"Centos 7.2 安装和卸载 MySQL 5.7","date":"2017-10-02T07:14:45.000Z","path":"2017/10/02/Centos-7-2-安装和卸载-MySQL/","text":"一、背景闲暇之余在虚拟机安装了 Centos 7.2 系统，按照 《简单安装MySQL（RPM方式）》 这篇文章安装 MySQL ，发现由于包依赖的问题安装失败，于是索性在官网查询相关文档进行 MySQL 的安装。 二、安装2.1 下载本次安装选择 Installing MySQL on Linux Using the MySQL Yum Repository 方式 在 https://dev.mysql.com/downloads/repo/yum/ 选择需要安装的文件，笔者选择 MySQL 5.7 版本。 1wget https://dev.mysql.com/get/mysql57-community-release-el7-11.noarch.rpm 2.2 安装123rpm -ivh mysql57-community-release-el7-11.noarch.rpmyum install mysql-community-server 更多安装方式和细节请参照文章末尾的参考资料 2.3 登陆12345678# 重启 MySQL 服务service mysqld restart# 获取临时的登陆密码grep &apos;temporary password&apos; /var/log/mysqld.log# 根据上一步获取的密码登陆 MySQL 服务端mysql -uroot -p 2.4 修改密码123ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;新密码&apos;;flush privileges; 注意: MySQL 默认安装了 validate_password 插件，它要求设置的密码长度至少为 8 位数，且需要包含至少一个大写字母，一个小写字母，一个数字和一个特殊符号。 原文如下： 1234MySQL&apos;s validate_password plugin is installed by default. This will require that passwords contain at least one upper case letter, one lower case letter, one digit, and one special character, and that the total password lengthis at least 8 characters. 三、卸载3.1 查看 MySQL 安装的相关信息1rpm -qa | grep -i mysql 返回结果： 123456[root@localhost ~]# rpm -qa | grep -i mysqlmysql-community-common-5.7.19-1.el7.x86_64mysql-community-client-5.7.19-1.el7.x86_64mysql57-community-release-el7-11.noarchmysql-community-server-5.7.19-1.el7.x86_64mysql-community-libs-5.7.19-1.el7.x86_64 3.2 卸载123456789rpm -ev mysql-community-server-5.7.19-1.el7.x86_64rpm -ev mysql-community-client-5.7.19-1.el7.x86_64rpm -ev mysql-community-libs-5.7.19-1.el7.x86_64rpm -ev mysql57-community-release-el7-11.noarchrpm -ev mysql-community-common-5.7.19-1.el7.x86_64 3.3 删除残余文件1234567rm -rf /var/lib/mysqlrm -rf /usr/share/mysqlrm -f /var/log/mysqld.logrm -f /etc/my.cnf 四、参考资料 https://dev.mysql.com/doc/refman/5.7/en/linux-installation.html","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://www.extlight.com/tags/MySQL/"}]},{"title":"Elasticsearch 基础入门","date":"2017-09-27T02:58:59.000Z","path":"2017/09/27/Elasticsearch-基础入门/","text":"一、什么是 ElasticSearchElasticSearch是一个基于 Lucene 的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎，基于 RESTful web 接口。Elasticsearch 是用 Java 开发的，并作为 Apache 许可条款下的开放源码发布，是当前流行的企业级搜索引擎。设计用于云计算中，能够达到实时搜索，稳定，可靠，快速，安装使用方便。 1.1 基础概念索引：含有相同属性的文档集合 类型：索引可以定义一个或多个类型，文档必须属于一个类型 文档：可以被索引的基础数据单位 分片：每个索引都有多个分片，每个分片都是 Lucene 索引 备份：拷贝一份分片就完成分片的备份 形象比喻： 百货大楼里有各式各样的商品，例如书籍、笔、水果等。书籍可以根据内容划分成不同种类，如科技类、教育类、悬疑推理等。悬疑推理类的小说中比较有名气的有《福尔摩斯探案集》、《白夜行》等。 百货大楼 –&gt; ElasticSearch 数据库 书籍 –&gt; 索引 悬疑推理 –&gt; 类型 白夜行 –&gt; 文档 1.2 应用场景 海量数据分析引擎 站内搜索引擎 数据仓库 二、安装和配置 本次测试使用一台 ip 为 192.168.2.41 的虚拟机（Centos7），建议使用 7.x 版本，笔者之前使用 6.x 启动服务时报出各种错误 2.1 依赖环境JDK 和 NodeJS 2.2 下载登陆 elasticSearch 官网下载文件。 2.3 安装123tar -zxvf elasticsearch-5.6.1.tar.gz -C /usrcd elasticsearch-5.6.1 elasticsearch 文件目录如下图： 2.4 启动踩坑提醒 1： 因为 Elasticsearch 可以执行脚本文件，为了安全性，默认不允许通过 root 用户启动服务。我们需要新创建用户名和用户组启动服务 1234567891011#增加 es 组groupadd es #增加 es 用户并附加到 es 组useradd es -g es -p es #给目录权限chown -R es:es elasticsearch-5.6.1 #使用es用户su es 踩坑提醒 2： 默认情况下，Elasticsearch 只允许本机访问，如果需要远程访问，需要修改其配置文件 1234vim config/elasticsearch.yml # 去掉 network.host 前边的注释，将它的值改成0.0.0.0network.host: 0.0.0.0 踩坑提醒 3： 在启动过程中，Centos 环境下可能还会报错，具体解决方案请参照文章末尾提供的资料 启动服务 1bin/elasticsearch 通过浏览器访问 http://192.168.2.41:9200 ，当出现如下内容说明启动成功: 12345678910111213&#123; &quot;name&quot; : &quot;OwUwJe-&quot;, &quot;cluster_name&quot; : &quot;elasticsearch&quot;, &quot;cluster_uuid&quot; : &quot;vanzxnpaRumdRKiYic3f5A&quot;, &quot;version&quot; : &#123; &quot;number&quot; : &quot;5.6.1&quot;, &quot;build_hash&quot; : &quot;667b497&quot;, &quot;build_date&quot; : &quot;2017-09-14T19:22:05.189Z&quot;, &quot;build_snapshot&quot; : false, &quot;lucene_version&quot; : &quot;6.6.1&quot; &#125;, &quot;tagline&quot; : &quot;You Know, for Search&quot;&#125; 2.5 安装插件访问 http://192.168.2.41:9200 查看内容显示效果不友好，因此，我们需要安装一个名为 elasticsearch-head 的插件，让内容显示效果比较舒适。 登陆 GitHub 网站，搜索 mobz/elasticsearch-head ，将其下载到本地。 123456789wget https://github.com/mobz/elasticsearch-head/archive/master.zipunzip master.zipcd elasticsearch-head-masternpm installnpm run start 通过上述命令的操作，我们已经安装好 elasticsearch-head 插件。通过浏览器访问 http://192.168.2.41:9100，如下图: 图中我们发现 elasticsearch-head 插件和 Elasticsearch 服务并没有建立连接，所以我们还需要修改 Elasticsearch 的配置文件： 12345678cd elasticsearch-5.6.1vim config/elasticsearch.yml# 在文件末尾添加 2 段配置http.cors.enabled: truehttp.cors.allow-origin: &quot;*&quot; 保存文件后，分别起来 2 个程序： 123456789cd elasticsearch-5.6.1# 后台启动 elasticSearch 服务bin/elasticsearch -dcd elasticsearch-head-masternpm run start 通过浏览器访问 http://192.168.2.41:9100，如下图: 通过插件创建索引 查看索引基本情况 该插件能直接对 Elasticsearch 的数据进行增删改查，因此存在安全性的问题。建议生产环境下不要使用该插件！ 三、使用Elasticsearch 支持 RESTFUL 风格 API，其 API 基本格式如下： 1http://&lt;ip&gt;:&lt;port&gt;/&lt;索引&gt;/&lt;类型&gt;/&lt;文档id&gt; 3.1 创建/删除索引为了方便测试，我们使用 POSTMAN 工具进行接口的请求。 创建一个非结构化的索引，需要使用 PUT 请求。例如创建一个名为 book 的索引。 执行：1[PUT] http://192.168.2.41:9200/book 返回结果： 12345&#123; &quot;acknowledged&quot;: true, &quot;shards_acknowledged&quot;: true, &quot;index&quot;: &quot;book&quot;&#125; 创建一个结构化的索引，如下图： 删除一个索引，需要使用 DELETE 请求。 执行： 1[DELETE] http://192.168.2.41:9200/book 返回结果： 123&#123; &quot;acknowledged&quot;: true&#125; 3.2 插入数据插入指定 ID 的数据，需要使用 PUT 请求。如下图： 插入不指定 ID 的数据，需要使用 POST 请求。如下图： 3.3 修改数据修改数据，需要使用 POST 请求，且 URL 需要添加 _update 执行： 1[POST] http://192.168.2.41:9200/fruit/apple/1/_update 请求参数（修改颜色）： 12345&#123; &quot;doc&quot;: &#123; &quot;color&quot;: &quot;black&quot; &#125;&#125; 返回结果： 123456789101112&#123; &quot;_index&quot;: &quot;fruit&quot;, &quot;_type&quot;: &quot;apple&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 7, &quot;result&quot;: &quot;updated&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;&#125; 3.4 删除数据修改数据，需要使用 DELETE 请求。 执行： 1[DELETE] http://192.168.2.41:9200/fruit/apple/1 返回结果： 12345678910111213&#123; &quot;found&quot;: true, &quot;_index&quot;: &quot;fruit&quot;, &quot;_type&quot;: &quot;apple&quot;, &quot;_id&quot;: &quot;1&quot;, &quot;_version&quot;: 8, &quot;result&quot;: &quot;deleted&quot;, &quot;_shards&quot;: &#123; &quot;total&quot;: 2, &quot;successful&quot;: 1, &quot;failed&quot;: 0 &#125;&#125; 3.5 查找数据查询指定ID的数据，需要使用 GET 请求。 执行： 1[GET] http://192.168.2.41:9200/fruit/apple/AV69_4DDdZbC-YBdV-U3 返回结果： 123456789101112&#123; &quot;_index&quot;: &quot;fruit&quot;, &quot;_type&quot;: &quot;apple&quot;, &quot;_id&quot;: &quot;AV69_4DDdZbC-YBdV-U3&quot;, &quot;_version&quot;: 1, &quot;found&quot;: true, &quot;_source&quot;: &#123; &quot;color&quot;: &quot;green&quot;, &quot;weight&quot;: 1, &quot;createTime&quot;: &quot;2017-09-26 19:05:26&quot; &#125;&#125; 条件查询，需要使用 POST 请求。 执行： 1[POST] http://192.168.2.41:9200/fruit/apple/_search 请求参数（查找 color = “green”）： 1234567&#123; &quot;query&quot;: &#123; &quot;match&quot;:&#123; &quot;color&quot;: &quot;green&quot; &#125; &#125;&#125; 返回结果： 123456789101112131415161718192021222324252627&#123; &quot;took&quot;: 8, &quot;timed_out&quot;: false, &quot;_shards&quot;: &#123; &quot;total&quot;: 5, &quot;successful&quot;: 5, &quot;skipped&quot;: 0, &quot;failed&quot;: 0 &#125;, &quot;hits&quot;: &#123; &quot;total&quot;: 1, &quot;max_score&quot;: 0.2876821, &quot;hits&quot;: [ &#123; &quot;_index&quot;: &quot;fruit&quot;, &quot;_type&quot;: &quot;apple&quot;, &quot;_id&quot;: &quot;AV69_4DDdZbC-YBdV-U3&quot;, &quot;_score&quot;: 0.2876821, &quot;_source&quot;: &#123; &quot;color&quot;: &quot;green&quot;, &quot;weight&quot;: 1, &quot;createTime&quot;: &quot;2017-09-26 19:05:26&quot; &#125; &#125; ] &#125;&#125; 参考资料 http://blog.csdn.net/qq942477618/article/details/53414983 解决问题方案 http://blog.csdn.net/laotoumo/article/details/53890279 解决问题方案 http://blog.csdn.net/jiankunking/article/details/65448030 解决问题方案 http://www.ruanyifeng.com/blog/2017/08/elasticsearch.html http://www.cnblogs.com/ghj1976/p/5293250.html","tags":[{"name":"Elasticsearch","slug":"Elasticsearch","permalink":"http://www.extlight.com/tags/Elasticsearch/"},{"name":"搜索","slug":"搜索","permalink":"http://www.extlight.com/tags/搜索/"}]},{"title":"记一次跨域问题的解决方案","date":"2017-09-26T02:45:28.000Z","path":"2017/09/26/记一次跨域问题的解决方案/","text":"一、背景在公司空暇时间，笔者使用 AngularJS + SSM 方案编写一套权限控制系统。由于采用的是前后端分离的思想，前端页面服务启动的端口和后端服务启动端口不一致导致请求跨域问题的出现。在此，写下解决问题的流程。 二、基础知识2.1 什么是同源URL 由协议、域名、端口和路径组成，如果两个 URL 的协议、域名和端口相同，则表示它们同源。 2.2 什么是同源策略浏览器的同源策略，限制了来自不同源的 document 或脚本，对当前 document 读取或设置某些属性。其目的是为了保证用户信息的安全，防止恶意的网站窃取数据。 另外，同源策略只对网页的 HTML 文档做了限制，对加载的其他静态资源如 javascript、css、图片等仍然认为属于同源。 2.3 什么是跨域跨域，指的是浏览器不能执行其他网站的脚本。同源策略规定，AJAX 请求只能发给同源的网址，否则就报错。 建议读者先浏览文章末尾提供的参考资料进一步了解跨域相关的内容，再结合本文案例思考和理解 三、解决案例CORS 是一个 W3C 标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出 XMLHttpRequest 请求，从而克服了 AJAX 只能同源使用的限制。 笔者采用 CORS 方案解决问题。 3.1 前端页面设置3.1.1 设置请求参数在 ajax 请求参数中添加 2 个参数设置： 12xhrFields: &#123; withCredentials: true &#125;crossDomain: true 3.1.2 源码演示123456789101112131415161718$.ajaxSetup(&#123; dataType: \"json\", cache: false, xhrFields: &#123; withCredentials: true &#125;,//设置后，请求会携带cookie crossDomain: true, complete: function(xhr) &#123; if (xhr.responseJSON) &#123; if (xhr.responseJSON.code == 401) &#123; layer.msg(xhr.responseJSON.msg); setTimeout(function() &#123; window.location.href = \"login.html\"; &#125;, 1500); &#125; &#125; else &#123; layer.msg(xhr.responseText); &#125; &#125;&#125;); 3.2 后端服务器设置3.2.1 设置跨域请求过滤器1234567891011121314151617181920212223242526public class SimpleCORSFilter implements Filter &#123; public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws IOException, ServletException &#123; HttpServletResponse response = (HttpServletResponse) resp; HttpServletRequest request=(HttpServletRequest)req; // 处理简单请求 // 跨域请求默认不携带cookie,如果要携带cookie，需要设置下边2个响应头 response.setHeader(\"Access-Control-Allow-Origin\", request.getHeader(\"Origin\"));// 必选，所有有效的跨域响应都必须包含这个请求头, 没有的话会导致跨域请求失败 response.setHeader(\"Access-Control-Allow-Credentials\", \"true\");//可选，此处设置为true,对应前端 xhr.withCredentials = true; //处理非简单请求 // 非简单请求：浏览器会发送两个请求, 第一个请求(成为预检请求)会像服务器确定是否接受这个跨域请求, 第二个才是真正的发出请求. 浏览器自动的处理这两个请求, 同时预检请求也是可以被缓存的, 而不用每次请求都需要发送预检请求. // 预检请求是在实际的请求发出前先向服务器确认是否能够处理这个请求. 服务器应该检查上边两个请求头的值, 来判断这个请求是否有效. response.setHeader(\"Access-Control-Allow-Methods\", \"POST,GET,OPTIONS,DELETE\");// 必选 response.setHeader(\"Access-Control-Allow-Headers\", \"Origin,No-Cache,X-Requested-With,If-Modified-Since,\" + \"Pragma,Last-Modified,Cache-Control,Expires,Content-Type,X-E4M-With,userId,token\"); response.setHeader(\"Access-Control-Max-Age\", \"0\");// 可选,在每个请求前面都发送一个预检请求是很浪费资源的, 这个值允许你设置预检请求的缓存时间, 单位是秒. response.setHeader(\"XDomainRequestAllowed\",\"1\"); chain.doFilter(req,resp); &#125; public void init(FilterConfig filterConfig) &#123;&#125; public void destroy() &#123;&#125;&#125; 3.2.2 配置 web.xml 文件12345678&lt;filter&gt; &lt;filter-name&gt;cors&lt;/filter-name&gt; &lt;filter-class&gt;com.light.system.web.filter.SimpleCORSFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;cors&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 四、参考资料 http://lleohao.com/2017/08/12/%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F/ http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html http://www.ruanyifeng.com/blog/2016/04/cors.html","tags":[{"name":"跨域","slug":"跨域","permalink":"http://www.extlight.com/tags/跨域/"}]},{"title":"jQuery 性能优化技巧","date":"2017-09-23T00:31:21.000Z","path":"2017/09/23/jQuery-性能优化技巧/","text":"一、使用最新版本 jQuery 类库二、合理使用选择器1234567891011121314# 推荐使用$(\"#id\") # 可以使用$(\"p\"),$(\"span\") # 可以使用$(\".class\") # 尽量避免$(\"[attribute=value]\") # 尽量避免$(\":hidden\") 三、使用缓存对象场景：修改某个按钮的文本和颜色 12345# 不好的写法$(\"#btn\").text(\"重置\");$(\"#btn\").css(\"color\",\"red\"); 12345# 优化的写法var $btn = $(\"#btn\");$btn.text(\"重置\").css(\"color\",\"red\"); 四、循环时减少对DOM的操作场景：往 &lt;ul&gt; 中添加 &lt;li&gt; 菜单项 1234567# 不好的写法var $ul = $(\"#menu\");for(var i=0; i&lt;6; i++) &#123; $ul.append(\"&lt;li&gt;菜单\"+i+\"&lt;/li&gt;\")&#125; 12345678910# 优化的写法var $ul = $(\"#menu\");var html = \"\";for(var i=0; i&lt;6; i++) &#123; html += \"&lt;li&gt;菜单\"+i+\"&lt;/li&gt;\";&#125;$ul.append(html); 五、使用事件代理场景：给 &lt;ul&gt; 里的所有 &lt;li&gt; 绑定点击变色事件 12345# 不好的写法$(\"ul li\").on(\"click\",function() &#123; $(this).css(\"color\",\"red\"); &#125;); 123456# 优化的写法$(\"ul li\").on(\"click\",function(e) &#123; var $obj = $(e.target); $obj.css(\"color\",\"red\"); &#125;); 六、将代码转成 jQuery 插件七、使用 join() 拼接字符串第四点的案例中，代码还可以进行优化 12345678var $ul = $(\"#menu\");var arr = [];for(var i=0; i&lt;6; i++) &#123; arr.push(\"&lt;li&gt;菜单\"+i+\"&lt;/li&gt;\");&#125;$ul.append(arr.join(\"\"); 八、合理利用 HTML5 的 data 属性使用 data-* 属性来嵌入自定义数据。 1&lt;div id=\"user\" data-age=\"26\" data-gender=\"男\"&gt;张三&lt;/div&gt; 12345var user = $(\"#user\");var age = user.data(\"age\");var gender = $(\"#user\").data(\"gender\"); 九、尽量使用原生的 JS 方法第五点的案例中，可以如下优化 1234$(\"ul li\").on(\"click\",function(e) &#123; var $obj = $(e.target); $obj.get(0).style.color = \"red\";&#125;); 十、压缩 JS 代码如有更多优化技巧，后续补充……","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://www.extlight.com/tags/Javascript/"},{"name":"jQuery","slug":"jQuery","permalink":"http://www.extlight.com/tags/jQuery/"}]},{"title":"UML 类图介绍","date":"2017-09-20T07:05:07.000Z","path":"2017/09/20/UML-类图介绍/","text":"一、基本概念类图是描述类、接口以及类之间关系的图。 1.1 作用类图常用来描述业务或软件系统的组成、结构和关系 1.2 类描述类在 UML 中通常以实线矩形框表示。矩形框中有若干分隔框，分别包含类名、属性、行为等元素。如下图： 类名：图中蓝色背景的字，如果字体为斜体，表名该类为抽象类属性：类名下边的区域行为：属性下边的区域可见性：属性和行为前边的 “+”、”-“ 和 “#”（图中未标注） 分别表示 public、private 和 protected 1.3 接口描述接口的类图表述与类大致相同，不同的是接口名要添加 Interface 标识，且行为的可见性必须用 “+” 表示。如下图： 二、类图中的六种关系 继承 实现 关联 依赖 组合 聚合 2.1 继承（Inherit）继承是面向对象语言的三个特性之一。子类继承父类，子类可以使用父类所有非私有的属性和方法，其UML类图表示如下： UML 类图中继承关系使用空心三角形+实线表示。 2.2 实现（Realization）实现与继承类似，实现类继承接口中的方法，但是方法必须由实现类自己实现，其UML类图表示如下： UML 类图中实现关系使用空心三角形+虚线表示。 2.3 关联（Association）指类与类之间的关系，它使得一个类知道另一个类的属性和方法。关联可以是双向的，也可以是单向的。 用 Java 代码表示企鹅只存在在南极，与气候有关系：123public class Penguin &#123; private Climate climate;&#125; 其UML类图表示如下： UML 类图中关联关系使用实线箭头表示。 2.4 依赖（Dependency）指类与类之间的联接，依赖关系表示一个类依赖于另一个类的定义。一般而言，依赖关系在Java语言中体现为局域变量、方法的形参，或者对静态方法的调用。 用 Java 代码表示程序员工作需要用到电脑：12345public class Programmer&#123; public void work(Computer computer) &#123; &#125;&#125; 其UML类图表示如下： UML 类图中依赖关系使用虚线箭头表示。 2.5 组合（Composition）关联关系的一种，表示一种强的“拥有”关系，体现了严格的部分和整体的关系，部分和整体的生命周期一样。 用 Java 表示每只鸟都有翅膀：123456public class Bird &#123; private Wing wing; public Bird() &#123; wing = new Wing(); &#125;&#125; 其UML类图表示如下： UML 类图中组合关系使用实心菱形实线表示。 2.6 聚合（Aggressgation）关联关系的一种，表示一种弱的“拥有”关系，体现的是A对象可以包含B对象，但是B对象不是A对象的一部分。 用 Java 代码表示大雁是群居动物，每只大雁都属于一个雁群，一个雁群可以有多只大雁：123public class WildGooseAggregate &#123; private List&lt;WildGoose&gt; wideGooses;&#125; 其UML类图表示如下： UML 类图中聚合关系使用空心菱形实线表示。 三、参考资料 http://www.cnblogs.com/javawebsoa/archive/2013/08/01/3230737.html","tags":[{"name":"UML","slug":"UML","permalink":"http://www.extlight.com/tags/UML/"}]},{"title":"原生 Javascript 编写贪吃蛇","date":"2017-09-18T06:45:23.000Z","path":"2017/09/18/原生-Javascript-编写贪吃蛇/","text":"一、简单介绍1.1 效果展示 1.2 实现思路 地图：创建一个 800px * 400px 的 div 元素来充当地图；地图可以看作由 40 x 20 个小 div（宽高都为20px） 元素组成。 食物：创建一个 宽高都为 20px 的 div 充当食物；食物通过 Math.random 分配随机位置。 蛇：创建一个二维数组充当蛇；二维数组存放蛇节（3个蛇身和1个蛇头），一维数组存放蛇节的位置、颜色和下一个蛇节对象。 蛇移动：先移动蛇尾，再移动蛇头。当前移动的蛇节位置为下一个蛇节未移动时的位置。 1.3 设计技术点DOM操作、面向对象、事件操作和间隔函数setInterval 1.4 项目结构 二、实现步骤2.1 绘制地图2.1.1 style.css 文件1234567891011html,body &#123; margin:0; padding: 0;&#125;.map &#123; margin: 100px auto; text-align: center; background-color: pink; position: relative;&#125; 2.1.2 map.js 文件12345678910111213141516var Map = function(width,height) &#123; this.width = width; this.height = height; this.id = \"map\";&#125;Map.prototype.showMap = function(containerId) &#123; // 创建地图并设置样式 var mapDiv = document.createElement(\"div\"); mapDiv.style.width = this.width +\"px\"; mapDiv.style.height = this.height + \"px\"; mapDiv.className = this.id; mapDiv.id = this.id; // 将创建的地图添加到页面中 document.getElementById(containerId).appendChild(mapDiv);&#125; 2.1.3 game.js 文件创建地图12345678var Game = function() &#123;&#125;Game.prototype.start = function() &#123; var map = new Map(800, 400); // 长宽数值必须是2的整数倍 map.showMap(\"container\");&#125; 2.1.4 index.html 文件开始游戏123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"zh\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;贪吃蛇&lt;/title&gt; &lt;link rel=\"stylesheet\" type=\"text/css\" href=\"css/style.css\"&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"container\"&gt;&lt;/div&gt; &lt;script type=\"text/javascript\" src=\"js/map.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/food.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/snake.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"js/game.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var game = new Game(); game.start(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2.1.5 效果 2.2 绘制食物2.2.1 food.js 文件12345678910111213141516171819202122232425262728var Food = function(map) &#123; this.size = 20; // 食物大小 this.xFood = 0; // 食物x坐标 this.yFood = 0; // 食物y坐标 this.map = map; // 坐在地图 this.foodDiv = null; // 地图中的食物&#125;Food.prototype.showFood = function() &#123; // 此处判断确保地图中只有一个食物 if (this.foodDiv === null) &#123; // 创建食物并设置样式 this.foodDiv = document.createElement(\"div\"); this.foodDiv.style.width = this.foodDiv.style.height = this.size + \"px\"; this.foodDiv.style.backgroundColor = \"red\"; this.foodDiv.style.position = \"absolute\"; // 将食物添加到地图上 document.getElementById(this.map.id).appendChild(this.foodDiv); &#125; // 食物步进值：20px // 食物权值坐标：X轴（0 - map.width/this.size）Y轴（0 - map.height/this.size） this.xFood = Math.floor(Math.random() * (this.map.width / this.size)); this.yFood = Math.floor(Math.random() * (this.map.height / this.size)); // 设置食物在地图的位置 this.foodDiv.style.left = this.xFood * this.size + \"px\"; this.foodDiv.style.top = this.yFood * this.size + \"px\";&#125; 2.2.2 game.js 文件创建地图和食物对象1234567891011var Game = function() &#123;&#125;Game.prototype.start = function() &#123; var map = new Map(800, 400); // 长宽数值必须是2的整数倍 map.showMap(\"container\"); var food = new Food(map); food.showFood();&#125; 2.2.3 效果 2.3 绘制小蛇2.3.1 snake.js 文件123456789101112131415161718192021222324252627282930313233var Snake = function(food) &#123; this.size = 20; // 初始化蛇&#123;x坐标，y坐标，颜色，蛇节对象&#125; this.snakeBody = [ &#123;x:0,y:1,color:\"black\",obj:null&#125;,// 蛇身 &#123;x:1,y:1,color:\"black\",obj:null&#125;,// 蛇身 &#123;x:2,y:1,color:\"black\",obj:null&#125;,// 蛇身 &#123;x:3,y:1,color:\"white\",obj:null&#125;// 蛇头 ]; this.direction = \"right\"; // 蛇移动方向 this.food = food; //食物&#125;// 显示蛇Snake.prototype.showSnake = function() &#123; //遍历蛇节，依次创建 for (var i = 0; i &lt; this.snakeBody.length; i++)&#123; //此处判断为了避免重复创建蛇节 if (this.snakeBody[i].obj == null) &#123; // 创建蛇节div，设置样式 this.snakeBody[i].obj = document.createElement(\"div\"); this.snakeBody[i].obj.style.width = this.snakeBody[i].obj.style.height = this.size + \"px\"; this.snakeBody[i].obj.style.backgroundColor = this.snakeBody[i].color; this.snakeBody[i].obj.style.position = \"absolute\"; // 追加蛇节 document.getElementById(this.food.map.id).appendChild(this.snakeBody[i].obj); &#125; // 设置蛇在地图中的位置 this.snakeBody[i].obj.style.left = this.snakeBody[i].x * this.size + \"px\"; this.snakeBody[i].obj.style.top = this.snakeBody[i].y * this.size + \"px\"; &#125;&#125; 2.3.2 game.js 文件创建地图、食物和蛇对象123456789101112131415var Game = function() &#123;&#125;Game.prototype.start = function() &#123; var map = new Map(800, 400); // 长宽数值必须是2的整数倍 map.showMap(\"container\"); var food = new Food(map); food.showFood(); var snake = new Snake(food); snake.showSnake();&#125; 2.3.3 效果 2.4 小蛇移动2.4.1 snake.js 文件，添加move方法12345678910111213141516171819202122232425262728// 移动蛇Snake.prototype.move = function() &#123; // 非蛇头蛇节（当前蛇节的新坐标 为 下个蛇节的旧坐标） for (var i=0; i&lt;this.snakeBody.length -1; i++) &#123; this.snakeBody[i].x = this.snakeBody[i+1].x; this.snakeBody[i].y = this.snakeBody[i+1].y; &#125; // 设置蛇头位置 if (this.direction == \"right\") &#123; // 蛇头x坐标累加 this.snakeBody[this.snakeBody.length - 1].x += 1; &#125; if (this.direction == \"left\") &#123; // 蛇头x坐标累加 this.snakeBody[this.snakeBody.length - 1].x -= 1; &#125; if (this.direction == \"up\") &#123; // 蛇头x坐标累加 this.snakeBody[this.snakeBody.length - 1].y -= 1 &#125; if (this.direction == \"down\") &#123; // 蛇头x坐标累加 this.snakeBody[this.snakeBody.length - 1].y += 1; &#125; this.showSnake();&#125; 2.4.2 game.js 文件使用 interval 函数调用蛇对象的move方法12345678910111213141516171819var Game = function() &#123;&#125;Game.prototype.start = function() &#123; var map = new Map(800, 400); // 长宽数值必须是2的整数倍 map.showMap(\"container\"); var food = new Food(map); food.showFood(); var snake = new Snake(food); snake.showSnake(); setInterval(function() &#123; snake.move(); &#125;, 100);&#125; 2.5 控制小蛇移动方向game.js 添加键盘按下事件 12345678910111213141516171819202122232425262728293031323334353637var Game = function() &#123;&#125;Game.prototype.start = function() &#123; var map = new Map(800, 400); // 长宽数值必须是2的整数倍 map.showMap(\"container\"); var food = new Food(map); food.showFood(); var snake = new Snake(food); snake.showSnake(); setInterval(function() &#123; snake.move(); &#125;, 100); // 键盘控制 document.onkeydown = function(e) &#123; switch (e.keyCode) &#123; case 37: snake.direction = \"left\"; break; case 38: snake.direction = \"up\"; break; case 39: snake.direction = \"right\"; break; case 40: snake.direction = \"down\"; break; &#125; snake.showSnake(); &#125;&#125; 2.6 小蛇吃食物snake.js 文件在 move 方法 this.showSnake() 之前添加逻辑判断 123456789101112// 蛇头坐标var xSnakeHead = this.snakeBody[this.snakeBody.length -1].x;var ySnakeHead = this.snakeBody[this.snakeBody.length -1].y;//判断蛇吃否吃到食物if (xSnakeHead == this.food.xFood &amp;&amp; ySnakeHead == this.food.yFood) &#123; // 增加蛇长 var newBody = &#123;x:this.snakeBody[0].x,y:this.snakeBody[0].y,color:\"black\",obj:null&#125;; this.snakeBody.unshift(newBody); // 食物消失，再随机生成 this.food.showFood();&#125; 2.7 小蛇移动范围snake.js 文件在 move 方法 this.showSnake() 之前添加逻辑判断 123456789101112131415// 控制小蛇移动范围if (xSnakeHead &lt; 0 || xSnakeHead &gt;= this.food.map.width/this.size || ySnakeHead &lt;0 || ySnakeHead &gt;= this.food.map.height/this.size) &#123; alert(\"游戏结束!\"); window.location.reload();&#125;// 不能吃自己for (var j=0; j&lt;this.snakeBody.length -1; j++) &#123; // 蛇头坐标 = 蛇身坐标，游戏结束 if (this.snakeBody[j].x == xSnakeHead &amp;&amp; this.snakeBody[j].y == ySnakeHead) &#123; alert(\"游戏结束!\"); window.location.reload(); &#125;&#125; 三、源码下载贪吃蛇","tags":[{"name":"Javascript","slug":"Javascript","permalink":"http://www.extlight.com/tags/Javascript/"}]},{"title":"学习 Git 玩转 GitHub","date":"2017-09-18T03:26:50.000Z","path":"2017/09/18/学习Git玩转GitHub/","text":"一、基本了解1.1 什么是版本控制系统版本控制系统是一种记录一个或若干个文件内容变化，以便将来查阅特定版本修订情况的系统。 1.2 什么是 GitGit是一个免费、开源的版本控制软件 1.3 什么是 GithubGithub是全球最大的社交编程及代码托管网站 1.4 Git 和 GitHub 的关系 Git是版本控制软件 Github是项目代码托管的平台，借助git来管理项目代码 1.5 什么要学习 GitHub 学习优秀的开源项目 关注行业前辈了解最新的行业动态 二、使用 GitHub2.1 目的借助 GitHub 托管项目代码 2.2 GitHub 中的基本概念2.2.1 Repository（仓库）仓库用来存放项目代码，每个项目对应一个仓库，多个开源项目则有多个仓库 2.2.2 Watch（关注）关注项目，当项目更新可以接收到通知 2.2.3 Star（收藏）收藏项目，方便下次查看 2.2.4 Fork（复制克隆项目）复制克隆别人的项目到自己的 Github 仓库中，独立存在，任何操作都不会对原先的仓库造成影响。 2.2.5 Issue（问题讨论）发现代码 bug 时，发起消息与作者讨论 2.2.6 Pull Request（发起请求）当 fork 仓库，修改仓库的 bug 或 添加新功能后，想同步到原先的仓库时，发起请求给原仓库作者，让其对代码审核与合并。 2.3 注册 GitHub 账号第一步：登陆官网 GitHub官网，如下图： 第二步：点击首页右上角的 “Sign up”，进入如下页面： 填写好信息，点击 “Create an account”，来到如下页面： GitHub已经帮我们设置好默认选项，我们只管点击左下角绿色按钮即可。 当看到下边的界面时，我们就注册好账号了： 2.4 创建仓库/创建新项目点击上图 “Start a project” 按钮创建项目（仓库）。但是，由于我们刚注册好账号，并没有对邮件地址进行合法校验。所以会出现如下界面： 点击 红色框住的链接，GitHub 会跳转页面且重新发送一封邮件让我们进行对邮箱地址的校验。如图： 笔者使用的是 qq 邮箱，点击右下角提示进入到 qq 邮箱管理界面，如图： 点击 “Verify email address” 连接进行校验，浏览器会打开新标签提示邮箱地址校验成功。 此时，我们点击 “Start a project” 就能真正创建项目了。此时，我们会来到如下界面： 填写好基本信息，点击 “Create a repository”，来到仓库管理界面： 根据图中的标注，我们可以根据自己的需求管理仓库。 2.5 开源项目贡献流程2.5.1 新建Issue提交使用问题、建议或者想法 2.5.2 Pull Request fork 项目 修改自己仓库的项目代码 新建 pull request 等待作者操作审核 三、使用 Git3.1 目的通过 Git 管理 GitHub 托管项目代码 3.2 下载安装登陆 https://www.git-scm.com/download/win 下载 安装过程傻瓜化方式（在选择安装时，选择 Git Bash 和 Git GUI ，其余默认选项即可），步骤省略。 3.3 Git 工作原理对于任何一个文件，在 Git 内都只有三种状态：已提交（committed），已修改（modified）和已暂存（staged）。已提交表示该文件已经被安全地保存在本地数据库中了；已修改表示修改了某个文件，但还没有提交保存；已暂存表示把已修改的文件放在下次提交时要保存的清单中。 由此我们看到 Git 管理项目时，文件流转的三个工作区域：Git 的工作目录，暂存区域，以及本地仓库。 每个项目都有一个 Git 目录（如果 git clone 出来的话，就是其中 .git 的目录）。它是 Git 用来保存元数据和对象数据库的地方。该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。 从项目中取出某个版本的所有文件和目录，用以开始后续工作的叫做工作目录。这些文件实际上都是从 Git 目录中的压缩对象数据库中提取出来的，接下来就可以在工作目录中对这些文件进行编辑。 所谓的暂存区域只不过是个简单的文件，一般都放在 Git 目录中。有时候人们会把这个文件叫做索引文件，不过标准说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改某些文件 对修改后的文件进行快照，然后保存到暂存区域 提交更新，将保存在暂存区域的文件快照永久转储到 Git 目录中。 3.4 Git 基本命令3.4.1 git init初始化工作目录，在当前目录下会创建一个名为 .git 的隐藏文件夹。 3.4.2 git add创建或编辑文件后，执行该命令，将文件添加到暂存区 3.4.3 git commit将暂存区的文件推送到仓库中 3.4.4 git status列出当前目录所有还没有被 Git 管理的文件和被 Git 管理且被修改但还未提交(git commit)的文件 3.4.5 git fetch检测远程仓库所有分支 3.4.6 git checkout切换分支 3.4.7 git branch查看当前所在分支 3.4.8 git rm删除仓库中的文件 3.4.9 git clone克隆远程仓库 3.4.10 git push同步本地仓库到远程仓库 3.5 Git 管理远程仓库Git 连接和管理 GitHub 上的文件，为了安全性，需要设置公钥。 之前的步骤我们安装了 Git，打开 Git 安装目录下的 Git Bash ，键入 1ssh-keygen -t rsa -C &quot;GitHub邮箱地址&quot; 命令执行后会提示输入信息，我们不用填写，直接回车。最终会在系统 “C:/Users/用户名/.ssh/“ 目录中生成 rsa 和 rsa.pub 文件。 打开 rsa.pub 文件复制里边的所有内容。 回到 GitHub 中，按照如下图操作： 最后我们进行测试，在 Git Bash 中键入： 1ssh -T git@github.com 如果出现 “Hi xxx! You’ve successfully authenticated” 字样，说明我们配置成功了。 下边我们模拟场景运用 Git 命令将文件提交到 GitHub 的仓库中。 场景一：非 clone 方式该场景下，我们没有对远程仓库进行关联，需要手动初始化 .git 文件夹 在 “E:\\demo\\git\\test1”（自定义） 中，使用 Git Bash 或 CMD 键入： 123456789101112131415161718192021git initecho &quot;hello world&quot; &gt; test.txtgit add .git statusgit commit -m &quot;first commit&quot;#添加需要连接的远程仓库地址（关联远程仓库）git remote add origin git@github.com:bluesky960/test.git git fetch # 切换到 master 分支git checkout master git branch git push origin master 此时，在 Github 的 test 仓库中会多出 test.txt 文件。 场景二：clone 方式 在 “E:\\demo\\git\\test2”（自定义） 中，使用 Git Bash 或 CMD 键入： 123456789101112# 执行 clone 操作会在当前目录中创建 .git 文件夹，关联远程仓库git clone git@github.com:bluesky960/test.gitcd testecho &quot;clone hello world&quot; &gt; test2.txtgit add .git commit -m &quot;add file&quot;git push 此时，在 Github 的 test 仓库中会多出 test2.txt 文件。 为了防止每次同步文件都需要输入账号和密码，我们需要进特殊配置 打开 Git Bash 窗口，键入： 123git config --global user.name &quot;GitHub用户名&quot; git config --global user.email &quot;GitHub邮箱地址&quot; 踩坑提醒 在执行 “git remote add origin” 命令时，后边跟着是 SSH 类型的仓库地址，否则，在每次 git push 时都要输入账号和密码！ 四、参考资料 http://www.nowamagic.net/academy/detail/48160210","tags":[{"name":"Git","slug":"Git","permalink":"http://www.extlight.com/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"http://www.extlight.com/tags/GitHub/"}]},{"title":"简单介绍","date":"2017-09-15T08:21:17.000Z","path":"2017/09/15/简单介绍/","text":"新博客上线 之前在博客园写博客，但是由于其排版和样式不够友好，因此笔者搭建新博客系统。以后就在这里博客。","tags":[{"name":"其他","slug":"其他","permalink":"http://www.extlight.com/tags/其他/"}]}]